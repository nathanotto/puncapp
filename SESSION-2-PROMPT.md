PUNCapp Session 2: Authentication, Core Schema, and First TaskContextSession 1 established the task infrastructure (TaskScreen components, pending_tasks table, task utilities). Now we build the first real task: Respond to Meeting RSVP.This session sets up authentication, creates the core tables needed for the RSVP flow, and builds the task end-to-end.Primary References1. TOD-SPECIFICATION.md — Flow 1: Meeting Cycle, specifically [TASK: Respond to Meeting RSVP]2. CLAUDE-CODE-GUIDE.md — Implementation patterns3. SPECIFICATION.md — Field details if needed (reference only)Step 1: Set Up Supabase Authentication1A: Enable Email Auth in SupabaseIn Supabase Dashboard:1. Authentication ? Providers2. Ensure Email provider is enabled3. For development, consider disabling "Confirm email" (Authentication ? Settings) to simplify testing1B: Create Auth HelpersCreate or verify these files exist:/lib/supabase/server.ts — Server-side Supabase client (for Server Components and Server Actions)/lib/supabase/client.ts — Client-side Supabase client (for Client Components)/lib/supabase/middleware.ts — For protecting routesFollow the Supabase Next.js guide patterns if these don't exist yet.1C: Create a Public Users TableSupabase Auth uses auth.users, but we need a public.users table for our app data (name, display preferences, chapter memberships, etc.).-- public.users mirrors auth.users with app-specific fieldsCREATE TABLE public.users (  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,  email text NOT NULL,  name text NOT NULL,  username text,  -- display name for privacy  display_preference text DEFAULT 'real_name' CHECK (display_preference IN ('real_name', 'username')),  phone text,  created_at timestamptz DEFAULT now(),  updated_at timestamptz DEFAULT now());-- Enable RLSALTER TABLE public.users ENABLE ROW LEVEL SECURITY;-- Policy: Users can read all users (for seeing chapter members)CREATE POLICY "Users can view all users" ON public.users  FOR SELECT USING (true);-- Policy: Users can update their own recordCREATE POLICY "Users can update own record" ON public.users  FOR UPDATE USING (auth.uid() = id);-- Trigger to create public.users row when auth.users is createdCREATE OR REPLACE FUNCTION public.handle_new_user()RETURNS trigger AS $$BEGIN  INSERT INTO public.users (id, email, name)  VALUES (new.id, new.email, COALESCE(new.raw_user_meta_data->>'name', 'New User'));  RETURN new;END;$$ LANGUAGE plpgsql SECURITY DEFINER;CREATE OR REPLACE TRIGGER on_auth_user_created  AFTER INSERT ON auth.users  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();1D: Create Simple Auth PagesCreate minimal auth pages to enable login/signup:/app/auth/login/page.tsx — Email + password login form /app/auth/signup/page.tsx — Email + password + name signup form /app/auth/logout/route.ts — Logout handler (can be a simple route handler)Keep these minimal—just functional forms. No fancy UI needed yet.1E: Create Auth Middleware/middleware.ts — Protect routes, redirect unauthenticated users to loginimport { createServerClient, type CookieOptions } from '@supabase/ssr'import { NextResponse, type NextRequest } from 'next/server'export async function middleware(request: NextRequest) {  // Public routes that don't require auth  const publicRoutes = ['/auth/login', '/auth/signup']  if (publicRoutes.some(route => request.nextUrl.pathname.startsWith(route))) {    return NextResponse.next()  }  let response = NextResponse.next({    request: { headers: request.headers },  })  const supabase = createServerClient(    process.env.NEXT_PUBLIC_SUPABASE_URL!,    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,    {      cookies: {        get(name: string) {          return request.cookies.get(name)?.value        },        set(name: string, value: string, options: CookieOptions) {          response.cookies.set({ name, value, ...options })        },        remove(name: string, options: CookieOptions) {          response.cookies.set({ name, value: '', ...options })        },      },    }  )  const { data: { user } } = await supabase.auth.getUser()  if (!user) {    return NextResponse.redirect(new URL('/auth/login', request.url))  }  return response}export const config = {  matcher: ['/((?!_next/static|_next/image|favicon.ico|api).*)'],}1F: Verify Auth Works1. Run the app2. You should be redirected to /auth/login3. Sign up with a test account4. You should be redirected to the main app5. Check Supabase: auth.users has your record, public.users has a matching recordStep 2: Create Core TablesCreate the tables needed for the RSVP flow. We're defining minimal fields for Session 2—add more as future flows require.-- Chapters: A group of men meeting regularlyCREATE TABLE chapters (  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),  name text NOT NULL,  status text DEFAULT 'open' CHECK (status IN ('forming', 'open', 'closed', 'splitting')),    -- Recurring schedule  meeting_frequency text CHECK (meeting_frequency IN ('weekly', 'biweekly', 'threeweekly', 'monthly')),  meeting_day_of_week integer CHECK (meeting_day_of_week BETWEEN 0 AND 6), -- 0 = Sunday  meeting_time time,  meeting_location text,    created_at timestamptz DEFAULT now(),  updated_at timestamptz DEFAULT now());ALTER TABLE chapters ENABLE ROW LEVEL SECURITY;-- For now, authenticated users can see all chaptersCREATE POLICY "Authenticated users can view chapters" ON chapters  FOR SELECT USING (auth.role() = 'authenticated');-- Chapter Memberships: Connecting users to chaptersCREATE TABLE chapter_memberships (  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),  chapter_id uuid NOT NULL REFERENCES chapters(id) ON DELETE CASCADE,  user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,  role text DEFAULT 'member' CHECK (role IN ('member', 'leader', 'backup_leader', 'scribe')),  member_type text DEFAULT 'regular' CHECK (member_type IN ('regular', 'contributing')),  is_active boolean DEFAULT true,  joined_at timestamptz DEFAULT now(),    UNIQUE(chapter_id, user_id));ALTER TABLE chapter_memberships ENABLE ROW LEVEL SECURITY;-- Members can see memberships in their chaptersCREATE POLICY "Users can view memberships in their chapters" ON chapter_memberships  FOR SELECT USING (    chapter_id IN (      SELECT chapter_id FROM chapter_memberships WHERE user_id = auth.uid()    )  );-- Meetings: A scheduled chapter gatheringCREATE TABLE meetings (  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),  chapter_id uuid NOT NULL REFERENCES chapters(id) ON DELETE CASCADE,    scheduled_date date NOT NULL,  scheduled_time time NOT NULL,  location text,    meeting_type text DEFAULT 'standard' CHECK (meeting_type IN ('standard', 'special_consideration')),  status text DEFAULT 'scheduled' CHECK (status IN ('scheduled', 'in_progress', 'completed', 'validated', 'cancelled')),    -- For special consideration meetings  topic text,  description text,    rsvp_deadline timestamptz, -- typically 2 days before meeting    created_at timestamptz DEFAULT now(),  updated_at timestamptz DEFAULT now());ALTER TABLE meetings ENABLE ROW LEVEL SECURITY;-- Members can see meetings for their chaptersCREATE POLICY "Users can view meetings in their chapters" ON meetings  FOR SELECT USING (    chapter_id IN (      SELECT chapter_id FROM chapter_memberships WHERE user_id = auth.uid()    )  );-- Attendance: RSVPs and actual attendanceCREATE TABLE attendance (  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),  meeting_id uuid NOT NULL REFERENCES meetings(id) ON DELETE CASCADE,  user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,    -- RSVP (before meeting)  rsvp_status text CHECK (rsvp_status IN ('yes', 'no', 'maybe', 'no_response')),  rsvp_reason text, -- required if rsvp_status = 'no'  rsvp_at timestamptz,    -- Actual attendance (during meeting)  attendance_type text CHECK (attendance_type IN ('in_person', 'video', 'absent')),  checked_in_at timestamptz,    created_at timestamptz DEFAULT now(),  updated_at timestamptz DEFAULT now(),    UNIQUE(meeting_id, user_id));ALTER TABLE attendance ENABLE ROW LEVEL SECURITY;-- Members can see attendance for meetings in their chaptersCREATE POLICY "Users can view attendance in their chapters" ON attendance  FOR SELECT USING (    meeting_id IN (      SELECT m.id FROM meetings m      JOIN chapter_memberships cm ON cm.chapter_id = m.chapter_id      WHERE cm.user_id = auth.uid()    )  );-- Users can insert/update their own attendanceCREATE POLICY "Users can manage own attendance" ON attendance  FOR ALL USING (user_id = auth.uid());Step 3: Update pending_tasks for RSVP FlowAdd RLS policies to pending_tasks if not already present:ALTER TABLE pending_tasks ENABLE ROW LEVEL SECURITY;-- Users can see their own pending tasksCREATE POLICY "Users can view own pending tasks" ON pending_tasks  FOR SELECT USING (assigned_to = auth.uid());-- Users can update their own pending tasks (mark complete)CREATE POLICY "Users can update own pending tasks" ON pending_tasks  FOR UPDATE USING (assigned_to = auth.uid());-- System can insert tasks (we'll use service role for this)-- For now, allow authenticated users to insert (simplifies seeding)CREATE POLICY "Authenticated users can insert pending tasks" ON pending_tasks  FOR INSERT WITH CHECK (auth.role() = 'authenticated');Step 4: Create Seed DataCreate a seed script or SQL to set up test data./scripts/seed.sql (run manually in Supabase SQL Editor after signing up)-- NOTE: Replace 'YOUR_USER_ID' with your actual auth.users id after signing up-- You can find it in Supabase Dashboard ? Authentication ? Users-- Create a test chapterINSERT INTO chapters (id, name, status, meeting_frequency, meeting_day_of_week, meeting_time, meeting_location)VALUES (  'a1b2c3d4-e5f6-7890-abcd-ef1234567890',  'The Oak Chapter',  'open',  'biweekly',  6,  -- Saturday  '09:00',  '123 Main St, Austin, TX');-- Make yourself a member (replace YOUR_USER_ID)INSERT INTO chapter_memberships (chapter_id, user_id, role)VALUES (  'a1b2c3d4-e5f6-7890-abcd-ef1234567890',  'YOUR_USER_ID',  'member');-- Create a meeting 7 days from nowINSERT INTO meetings (id, chapter_id, scheduled_date, scheduled_time, location, status, rsvp_deadline)VALUES (  'b2c3d4e5-f6a7-8901-bcde-f23456789012',  'a1b2c3d4-e5f6-7890-abcd-ef1234567890',  CURRENT_DATE + INTERVAL '7 days',  '09:00',  '123 Main St, Austin, TX',  'scheduled',  CURRENT_DATE + INTERVAL '5 days'  -- RSVP deadline 2 days before meeting);-- Create an attendance record (no RSVP yet)INSERT INTO attendance (meeting_id, user_id, rsvp_status)VALUES (  'b2c3d4e5-f6a7-8901-bcde-f23456789012',  'YOUR_USER_ID',  'no_response');-- Create the pending task for RSVPINSERT INTO pending_tasks (task_type, assigned_to, related_entity_type, related_entity_id, metadata, due_at)VALUES (  'respond_to_rsvp',  'YOUR_USER_ID',  'meeting',  'b2c3d4e5-f6a7-8901-bcde-f23456789012',  '{"chapter_name": "The Oak Chapter", "meeting_date": "' || (CURRENT_DATE + INTERVAL '7 days')::text || '"}',  CURRENT_DATE + INTERVAL '5 days'  -- Due at RSVP deadline);Step 5: Build the Dashboard with Pending TasksCreate a simple dashboard that shows the user's pending tasks./app/dashboard/page.tsxThis page should:1. Get the current user2. Fetch their pending tasks using getUserPendingTasks()3. Display using PendingTasksList component4. Each task links to its task screenFor respond_to_rsvp tasks, the link should be: /tasks/meeting-cycle/respond-to-rsvp?meeting={related_entity_id}Step 6: Build the RSVP Task ScreenThis is the core of Session 2. Follow TOD-SPECIFICATION.md Flow 1: [TASK: Respond to Meeting RSVP]./app/tasks/meeting-cycle/respond-to-rsvp/page.tsx6A: Load ContextThe task needs this context:* Meeting details (date, time, location)* Chapter name* RSVP deadline* Current RSVP status (if any)* User's pending commitments for this chapter (for Session 2, we can skip this—commitments come later)async function loadRsvpContext(meetingId: string, userId: string) {  // Fetch meeting with chapter info  // Fetch current attendance record (if exists)  // Return context or { authorized: false, reason: '...' } if user isn't in this chapter}6B: Build the Task ScreenUsing the TaskScreen component from Session 1:Prompt:* Title: "RSVP to Chapter Meeting"* Subtitle: "[Chapter Name] • [Date] at [Time]"Context:* Meeting date and time (formatted nicely)* Location* RSVP deadline* Current response (if they've already responded, show it)Actions:* Primary options: Yes / No / Maybe (radio or button group)* If "No" selected: show reason field (required)* Submit buttonConfirmation (on success):* Message: "RSVP recorded"* Consequence: "Your chapter will see your response." (If No: "Your chapter will see that you can't make it because: [reason]")* Downstream: none for member's RSVP (Leader/Backup see it via their dashboard, not a task)* Next step: "Nothing more needed until the meeting."6C: Create the Server Action/app/tasks/meeting-cycle/respond-to-rsvp/actions.ts'use server';import { createTaskResult } from '@/lib/task-utils';import { completeTask } from '@/lib/task-queue';export async function submitRsvp(formData: FormData): Promise<ActionResult> {  // 1. Get current user  // 2. Validate input (meetingId, rsvpStatus, reason if No)  // 3. Upsert attendance record  // 4. Find and complete the pending_task for this user/meeting  // 5. Return confirmation    return createTaskResult({    success: true,    message: 'RSVP recorded',    consequence: rsvpStatus === 'no'       ? `Your chapter will see that you can't make it because: ${reason}`      : 'Your chapter will see your response.',    nextStep: {      description: 'Nothing more needed until the meeting.',      href: '/dashboard',      label: 'Back to Dashboard',    },  });}6D: Handle Already RespondedIf user has already RSVPed (rsvp_status is not 'no_response'), show:* Their current response* Option to change it* Or just a view-only confirmation if we want to lock it inFor Session 2, let's allow changes—they can update their RSVP until the deadline.6E: Handle Past DeadlineIf current time is past rsvp_deadline:* Show TaskNotAvailable: "RSVP deadline has passed"* Or allow late RSVP with a note that it's lateFor Session 2, let's allow late RSVPs but show a warning.Step 7: Build the RSVP Summary ViewLeaders and Backup Leaders need to see who's responded. This isn't a "task" per se—it's a dashboard view./app/chapters/[chapterId]/meetings/[meetingId]/rsvps/page.tsxOr simpler for Session 2: /app/dashboard/meeting-rsvps/[meetingId]/page.tsxThis page shows:* Meeting details* List of all chapter members* Each member's RSVP status (Yes / No / Maybe / No Response)* For "No" responses, show the reason* Highlight "No Response" members (especially if past deadline)For Session 2, any chapter member can see this (you said the whole group sees responses). Leaders get it more prominently on their dashboard, but that's a layout concern for later.Step 8: Test the Complete Flow1. Log in2. See the RSVP task in your pending tasks on the dashboard3. Click it ? land on RSVP task screen4. See meeting details, deadline5. Select "Yes" ? Submit ? See confirmation6. Check: attendance record updated in Supabase7. Check: pending_task marked complete8. Go to RSVP summary page ? see your responseThen test the "No" flow:1. Create another test meeting/task (or reset the data)2. Select "No" ? Reason field appears3. Enter reason ? Submit ? Confirmation shows your reason4. RSVP summary shows your "No" with reasonWhat We're NOT Building in Session 2* Automatic meeting generation from recurring schedule (future session)* Automatic pending_task creation when meetings are scheduled (future session)* Email/SMS notifications (future session—pending_tasks is the trigger for now)* The 2-day-before escalation and "contact unresponsive member" task (Session 3)* Commitment display on RSVP screen (commitments come later)Session 2 Success Criteria* [ ] Can sign up and log in* [ ] public.users record created automatically on signup* [ ] Dashboard shows pending tasks* [ ] RSVP task screen displays with correct context (meeting details, deadline)* [ ] Can submit Yes/Maybe response, see confirmation* [ ] Can submit No response with required reason, see confirmation with reason* [ ] Attendance record created/updated in Supabase* [ ] Pending task marked complete after submission* [ ] RSVP summary page shows all members' responses* [ ] "No" responses display the reasonNotes for Future SessionsSession 3 will add:* RSVP deadline escalation (visual urgency on pending task)* contact_unresponsive_member task for Leader/Backup at 2 days before* Email notification when RSVP task is createdSession 4 will add:* Meeting check-in task* Beginning of the meeting runner flowNotification infrastructure pattern: The pending_tasks table is the notification queue. In future sessions, we'll add a background job (Supabase Edge Function or cron) that:1. Reads pending_tasks where notification not yet sent2. Sends email/SMS based on task type3. Marks notification as sent (add notified_at column)For now, in-app pending tasks list IS the notification.Remember: Build the task, prove the flow, then expand.