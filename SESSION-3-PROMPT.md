PUNCapp Session 3: RSVP Escalation & Leader OutreachContextSession 2 built the RSVP task flow. Now we add the escalation path: what happens when members don't respond.The timeline:WhenWhat Happens7 days beforeRSVP task created for all members3 days beforeNon-responders get simulated text + email reminder, task turns orange2 days before (deadline)If still no response: Leader/Backup get contact_unresponsive_member taskAfter Leader logs outreachBoth tasks complete, attendance updated, agenda item createdPrimary References1. TOD-SPECIFICATION.md Ñ Flow 1: Meeting Cycle, RSVP exception handling2. CLAUDE-CODE-GUIDE.md Ñ Implementation patterns3. SESSION-2-PROMPT.md Ñ What we built (RSVP task, attendance table, etc.)Step 1: Create the Notification Log TableThis table records all notifications (simulated for now, real later).CREATE TABLE notification_log (  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),  recipient_user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,  notification_type text NOT NULL CHECK (notification_type IN ('email', 'sms')),  purpose text NOT NULL, -- 'rsvp_reminder', 'task_created', 'meeting_reminder', etc.  status text NOT NULL DEFAULT 'simulated' CHECK (status IN ('simulated', 'pending', 'sent', 'failed')),    -- What would be / was sent  subject text, -- for email  content text NOT NULL,    -- For linking to related entities  related_entity_type text, -- 'meeting', 'task', etc.  related_entity_id uuid,    -- Tracking  created_at timestamptz DEFAULT now(),  sent_at timestamptz,    -- For future real sends  external_id text, -- ID from Resend/Twilio  error_message text);ALTER TABLE notification_log ENABLE ROW LEVEL SECURITY;-- Admins can see all (for now, let authenticated users see all for testing)CREATE POLICY "Authenticated users can view notification log" ON notification_log  FOR SELECT USING (auth.role() = 'authenticated');-- System inserts (service role), but for testing allow authenticatedCREATE POLICY "Authenticated users can insert notifications" ON notification_log  FOR INSERT WITH CHECK (auth.role() = 'authenticated');Step 2: Create the Meeting Agenda Items TableAuto-generated items (like "check in about non-responder") go here.CREATE TABLE meeting_agenda_items (  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),  meeting_id uuid NOT NULL REFERENCES meetings(id) ON DELETE CASCADE,    item_type text NOT NULL CHECK (item_type IN ('housekeeping', 'follow_up', 'custom')),  title text NOT NULL,  notes text,    -- For auto-generated items, link to source  source_type text, -- 'unresponsive_member_outreach', 'commitment_discrepancy', etc.  source_entity_id uuid,  related_user_id uuid REFERENCES public.users(id), -- the member this is about    -- Status  is_addressed boolean DEFAULT false,  addressed_at timestamptz,    created_at timestamptz DEFAULT now());ALTER TABLE meeting_agenda_items ENABLE ROW LEVEL SECURITY;-- Members can see agenda items for their chapter's meetingsCREATE POLICY "Users can view agenda items in their chapters" ON meeting_agenda_items  FOR SELECT USING (    meeting_id IN (      SELECT m.id FROM meetings m      JOIN chapter_memberships cm ON cm.chapter_id = m.chapter_id      WHERE cm.user_id = auth.uid()    )  );-- Leaders can insert/update (for now, allow authenticated for testing)CREATE POLICY "Authenticated users can manage agenda items" ON meeting_agenda_items  FOR ALL USING (auth.role() = 'authenticated');Step 3: Add Fields to Attendance TableWe need to track reminder status and leader outreach.ALTER TABLE attendance   ADD COLUMN IF NOT EXISTS reminder_sent_at timestamptz,  ADD COLUMN IF NOT EXISTS leader_outreach_logged_at timestamptz,  ADD COLUMN IF NOT EXISTS leader_outreach_notes text,  ADD COLUMN IF NOT EXISTS leader_outreach_by uuid REFERENCES public.users(id);Step 4: Add Urgency Field to Pending TasksTrack escalation state on tasks.ALTER TABLE pending_tasks  ADD COLUMN IF NOT EXISTS urgency text DEFAULT 'normal' CHECK (urgency IN ('normal', 'reminded', 'escalated'));Step 5: Create the Notification Log Viewer/app/admin/notifications/page.tsxA simple page showing all notification log entries. For testing the simulated flow.Displays:* Recipient name* Type (email/sms)* Purpose* Status (SIMULATED badge prominently displayed)* Subject (if email)* Content preview* TimestampFeatures:* Filter by status, type, purpose* Most recent first* Show "SIMULATED" prominently so it's clear nothing was actually sentStep 6: Create Notification Utility Functions/lib/notifications.tsimport { createClient } from '@/lib/supabase/server';interface SendNotificationParams {  recipientUserId: string;  type: 'email' | 'sms';  purpose: string;  subject?: string; // for email  content: string;  relatedEntityType?: string;  relatedEntityId?: string;}export async function sendNotification(params: SendNotificationParams) {  const supabase = await createClient();    // TODO: Replace with actual Resend (email) or Twilio (sms) call  // For now, we just log to notification_log with status 'simulated'    // Example future implementation for email:  // if (params.type === 'email') {  //   const { data, error } = await resend.emails.send({  //     from: 'PUNC <noreply@punchapters.org>',  //     to: recipientEmail,  //     subject: params.subject,  //     text: params.content,  //   });  //   if (error) {  //     // Log as failed  //   } else {  //     // Log as sent with external_id = data.id  //   }  // }    // Example future implementation for SMS:  // if (params.type === 'sms') {  //   const message = await twilioClient.messages.create({  //     body: params.content,  //     to: recipientPhone,  //     from: process.env.TWILIO_PHONE_NUMBER,  //   });  //   // Log with external_id = message.sid  // }    // For now: simulate  const { data, error } = await supabase    .from('notification_log')    .insert({      recipient_user_id: params.recipientUserId,      notification_type: params.type,      purpose: params.purpose,      status: 'simulated',      subject: params.subject,      content: params.content,      related_entity_type: params.relatedEntityType,      related_entity_id: params.relatedEntityId,    })    .select()    .single();      if (error) throw error;    console.log(`[SIMULATED ${params.type.toUpperCase()}] To: ${params.recipientUserId}`);  console.log(`Purpose: ${params.purpose}`);  console.log(`Content: ${params.content}`);    return data;}export async function sendRsvpReminder(userId: string, meetingId: string, meetingDetails: {  chapterName: string;  date: string;  time: string;  location: string;}) {  const content = `Hey brother, you haven't RSVPed for the upcoming ${meetingDetails.chapterName} meeting on ${meetingDetails.date} at ${meetingDetails.time}. Please respond so we know if you'll be there. - PUNC`;    // Send both email and SMS  await sendNotification({    recipientUserId: userId,    type: 'email',    purpose: 'rsvp_reminder',    subject: `RSVP needed: ${meetingDetails.chapterName} meeting on ${meetingDetails.date}`,    content,    relatedEntityType: 'meeting',    relatedEntityId: meetingId,  });    await sendNotification({    recipientUserId: userId,    type: 'sms',    purpose: 'rsvp_reminder',    content,    relatedEntityType: 'meeting',    relatedEntityId: meetingId,  });}Step 7: Create the Escalation Edge Function/supabase/functions/rsvp-escalation/index.tsThis function runs on a schedule (daily) and handles RSVP escalation.// NOTE: This is a Supabase Edge Function// Deploy with: supabase functions deploy rsvp-escalation// Schedule with: cron job in Supabase Dashboard or pg_cronimport { createClient } from '@supabase/supabase-js';const supabase = createClient(  Deno.env.get('SUPABASE_URL')!,  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!);Deno.serve(async (req) => {  try {    const now = new Date();        // ============================================    // STEP A: Find meetings 3 days away    // Send reminders to non-responders    // ============================================        const threeDaysFromNow = new Date(now);    threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3);    const threeDaysDate = threeDaysFromNow.toISOString().split('T')[0];        // Get meetings happening in 3 days    const { data: meetingsIn3Days } = await supabase      .from('meetings')      .select(`        id,        scheduled_date,        scheduled_time,        location,        chapter:chapters(id, name)      `)      .eq('scheduled_date', threeDaysDate)      .eq('status', 'scheduled');        for (const meeting of meetingsIn3Days || []) {      // Find non-responders who haven't been reminded yet      const { data: nonResponders } = await supabase        .from('attendance')        .select('id, user_id')        .eq('meeting_id', meeting.id)        .eq('rsvp_status', 'no_response')        .is('reminder_sent_at', null);            for (const attendance of nonResponders || []) {        // Log simulated notifications        // TODO: Replace with actual sendRsvpReminder call when notifications are real                // Simulated EMAIL        await supabase.from('notification_log').insert({          recipient_user_id: attendance.user_id,          notification_type: 'email',          purpose: 'rsvp_reminder',          status: 'simulated',          subject: `RSVP needed: ${meeting.chapter.name} meeting on ${meeting.scheduled_date}`,          content: `Hey brother, you haven't RSVPed for the upcoming ${meeting.chapter.name} meeting on ${meeting.scheduled_date} at ${meeting.scheduled_time}. Please respond so we know if you'll be there. - PUNC`,          related_entity_type: 'meeting',          related_entity_id: meeting.id,        });                // Simulated SMS        await supabase.from('notification_log').insert({          recipient_user_id: attendance.user_id,          notification_type: 'sms',          purpose: 'rsvp_reminder',          status: 'simulated',          content: `PUNC: You haven't RSVPed for ${meeting.chapter.name} on ${meeting.scheduled_date}. Please respond!`,          related_entity_type: 'meeting',          related_entity_id: meeting.id,        });                // Mark reminder sent        await supabase          .from('attendance')          .update({ reminder_sent_at: now.toISOString() })          .eq('id', attendance.id);                // Update pending task urgency to 'reminded'        await supabase          .from('pending_tasks')          .update({ urgency: 'reminded' })          .eq('task_type', 'respond_to_rsvp')          .eq('assigned_to', attendance.user_id)          .eq('related_entity_id', meeting.id)          .is('completed_at', null);      }    }        // ============================================    // STEP B: Find meetings 2 days away    // Create contact tasks for Leader/Backup    // ============================================        const twoDaysFromNow = new Date(now);    twoDaysFromNow.setDate(twoDaysFromNow.getDate() + 2);    const twoDaysDate = twoDaysFromNow.toISOString().split('T')[0];        // Get meetings happening in 2 days    const { data: meetingsIn2Days } = await supabase      .from('meetings')      .select(`        id,        scheduled_date,        chapter_id,        chapter:chapters(id, name)      `)      .eq('scheduled_date', twoDaysDate)      .eq('status', 'scheduled');        for (const meeting of meetingsIn2Days || []) {      // Find non-responders (still no response after reminder)      const { data: stillNoResponse } = await supabase        .from('attendance')        .select(`          id,           user_id,          user:users(id, name, username, phone)        `)        .eq('meeting_id', meeting.id)        .eq('rsvp_status', 'no_response')        .is('leader_outreach_logged_at', null);            if (!stillNoResponse?.length) continue;            // Get Leader and Backup Leader for this chapter      const { data: leaders } = await supabase        .from('chapter_memberships')        .select('user_id')        .eq('chapter_id', meeting.chapter_id)        .in('role', ['leader', 'backup_leader']);            // For each non-responder, create task for leaders      for (const attendance of stillNoResponse) {        const memberName = attendance.user.username || attendance.user.name;                // Update member's pending task urgency to 'escalated'        await supabase          .from('pending_tasks')          .update({ urgency: 'escalated' })          .eq('task_type', 'respond_to_rsvp')          .eq('assigned_to', attendance.user_id)          .eq('related_entity_id', meeting.id)          .is('completed_at', null);                // Create contact task for each leader        for (const leader of leaders || []) {          // Check if task already exists          const { data: existingTask } = await supabase            .from('pending_tasks')            .select('id')            .eq('task_type', 'contact_unresponsive_member')            .eq('assigned_to', leader.user_id)            .eq('related_entity_id', attendance.id) // Link to attendance record            .is('completed_at', null)            .single();                    if (!existingTask) {            await supabase.from('pending_tasks').insert({              task_type: 'contact_unresponsive_member',              assigned_to: leader.user_id,              related_entity_type: 'attendance',              related_entity_id: attendance.id,              metadata: {                member_user_id: attendance.user_id,                member_name: memberName,                member_phone: attendance.user.phone,                meeting_id: meeting.id,                meeting_date: meeting.scheduled_date,                chapter_name: meeting.chapter.name,              },              due_at: meeting.scheduled_date, // Due by meeting day            });                        // Log simulated notification to leader            await supabase.from('notification_log').insert({              recipient_user_id: leader.user_id,              notification_type: 'email',              purpose: 'task_created',              status: 'simulated',              subject: `Action needed: Contact ${memberName} about RSVP`,              content: `${memberName} hasn't responded to the RSVP for ${meeting.chapter.name} on ${meeting.scheduled_date}. Please reach out to check in with them.`,              related_entity_type: 'attendance',              related_entity_id: attendance.id,            });          }        }      }    }        return new Response(JSON.stringify({ success: true }), {      headers: { 'Content-Type': 'application/json' },    });      } catch (error) {    console.error('RSVP escalation error:', error);    return new Response(JSON.stringify({ error: error.message }), {      status: 500,      headers: { 'Content-Type': 'application/json' },    });  }});Deploying and Scheduling the Edge FunctionFor local testing, you can call this function manually or create an API route that triggers the same logic.For production, deploy with Supabase CLI and schedule with pg_cron:-- Enable pg_cron extension (do once in Supabase Dashboard ? Database ? Extensions)-- Then schedule the function to run daily at 9am UTC:SELECT cron.schedule(  'rsvp-escalation-daily',  '0 9 * * *',  $$  SELECT net.http_post(    url := 'https://YOUR_PROJECT_REF.supabase.co/functions/v1/rsvp-escalation',    headers := '{"Authorization": "Bearer YOUR_SERVICE_ROLE_KEY"}'::jsonb  );  $$);For Session 3 testing, create a manual trigger button or API route.Step 8: Create Manual Escalation Trigger (For Testing)Since we don't want to wait for cron jobs during development, create a way to manually trigger escalation./app/api/trigger-escalation/route.tsimport { NextResponse } from 'next/server';// Import the escalation logic (or duplicate it here)export async function POST() {  // Run the same logic as the edge function  // This lets you test escalation without waiting    // For now, can just call the edge function directly if deployed,  // or run the logic inline    return NextResponse.json({ success: true, message: 'Escalation triggered' });}/app/admin/notifications/page.tsx Ñ Add a "Trigger Escalation" button that calls this endpoint.Step 9: Update the RSVP List Page/app/meetings/[meetingId]/rsvps/page.tsxUpdate to show escalation status and Leader-specific features.For All Members:Display each member's row with:* Name/username* RSVP status (Yes / No / Maybe / No Response)* If No: show reason* If No Response + reminded: show "[username] texted and emailed, [leader_name] reaching out"* If outreach logged: show "Leader spoke with [username]: [notes preview]"For Leader/Backup Leader (additional features):* Non-responder rows show phone number* "Log Outreach" button/field appears for non-responders* Free text field to enter what happened* Submit logs the outreach and completes tasksContext Loading:async function loadRsvpListContext(meetingId: string, currentUserId: string) {  // Get meeting with chapter info  // Get all attendance records with user info  // Get current user's role in chapter (to know if they're leader)  // Get leader names for display    return {    meeting,    attendanceList,    isLeader: currentUserRole === 'leader' || currentUserRole === 'backup_leader',    leaderNames, // for "leader_name reaching out" display  };}Step 10: Build the Contact Unresponsive Member Task Screen/app/tasks/meeting-cycle/contact-unresponsive-member/page.tsxThis is the Leader's task to reach out to a non-responder.Context Needed (from pending_task metadata + lookups):* Member's name* Member's phone number* Meeting details (date, chapter name)* Current RSVP status (still no_response)Actor Sees:Prompt:* Title: "Contact [Member Name] About RSVP"* Subtitle: "[Chapter Name] meeting on [Date]"Context:* "[Member Name] hasn't responded to the RSVP."* "They were texted and emailed on [date] with no response."* Phone: [phone number] (tap to call on mobile)Action:* Free text field: "What happened when you reached out?"* Placeholder: "Called him, he's dealing with a family issue and won't make it..."* Submit button: "Log Outreach"Confirmation:* Message: "Outreach logged"* Consequence: "[Member Name]'s RSVP task has been resolved. This will be noted at the meeting."* Next step: "Back to Dashboard"Step 11: Create the Log Outreach Server Action/app/tasks/meeting-cycle/contact-unresponsive-member/actions.ts'use server';import { createClient } from '@/lib/supabase/server';import { createTaskResult, ActionResult } from '@/lib/task-utils';import { completeTask } from '@/lib/task-queue';export async function logOutreach(formData: FormData): Promise<ActionResult> {  const supabase = await createClient();    const attendanceId = formData.get('attendanceId') as string;  const notes = formData.get('notes') as string;  const taskId = formData.get('taskId') as string;    // Get current user (the leader logging this)  const { data: { user } } = await supabase.auth.getUser();  if (!user) throw new Error('Not authenticated');    // 1. Get the attendance record to find meeting and member  const { data: attendance } = await supabase    .from('attendance')    .select(`      id,      user_id,      meeting_id,      user:users(name, username),      meeting:meetings(id, chapter_id)    `)    .eq('id', attendanceId)    .single();    if (!attendance) {    return createTaskResult({      success: false,      message: 'Attendance record not found',      consequence: 'Please try again or contact support.',    });  }    const memberName = attendance.user.username || attendance.user.name;    // 2. Update attendance record with outreach notes  await supabase    .from('attendance')    .update({      leader_outreach_logged_at: new Date().toISOString(),      leader_outreach_notes: notes,      leader_outreach_by: user.id,      // Mark as resolved (not a true RSVP, but addressed)      rsvp_status: 'no', // Default to "not coming" Ñ leader's note explains    })    .eq('id', attendanceId);    // 3. Complete the leader's contact task  await completeTask(taskId);    // 4. Complete the member's RSVP task (if still open)  await supabase    .from('pending_tasks')    .update({ completed_at: new Date().toISOString() })    .eq('task_type', 'respond_to_rsvp')    .eq('assigned_to', attendance.user_id)    .eq('related_entity_id', attendance.meeting_id)    .is('completed_at', null);    // 5. Also complete any other leader's contact task for same member  await supabase    .from('pending_tasks')    .update({ completed_at: new Date().toISOString() })    .eq('task_type', 'contact_unresponsive_member')    .eq('related_entity_id', attendanceId)    .is('completed_at', null);    // 6. Create agenda item for the meeting  await supabase    .from('meeting_agenda_items')    .insert({      meeting_id: attendance.meeting_id,      item_type: 'housekeeping',      title: `Check in about ${memberName}`,      notes: notes,      source_type: 'unresponsive_member_outreach',      source_entity_id: attendanceId,      related_user_id: attendance.user_id,    });    return createTaskResult({    success: true,    message: 'Outreach logged',    consequence: `${memberName}'s RSVP task has been resolved. This will be noted at the meeting.`,    nextStep: {      description: 'Back to Dashboard',      href: '/dashboard',      label: 'Dashboard',    },  });}Step 12: Update Pending Task Display for UrgencyUpdate the PendingTaskCard component (or create if not exists) to show visual urgency./components/task/PendingTaskCard.tsxinterface PendingTaskCardProps {  task: {    id: string;    task_type: string;    urgency: 'normal' | 'reminded' | 'escalated';    metadata: any;    due_at: string | null;  };}export function PendingTaskCard({ task }: PendingTaskCardProps) {  // Determine styling based on urgency  const urgencyStyles = {    normal: 'border-gray-200 bg-white',    reminded: 'border-orange-300 bg-orange-50',    escalated: 'border-orange-500 bg-orange-100',  };    const urgencyBadge = {    normal: null,    reminded: <span className="text-xs bg-orange-200 text-orange-800 px-2 py-1 rounded">Texted & Emailed</span>,    escalated: <span className="text-xs bg-orange-300 text-orange-900 px-2 py-1 rounded">Leader Reaching Out</span>,  };    return (    <div className={`p-4 rounded-lg border-2 ${urgencyStyles[task.urgency]}`}>      <div className="flex justify-between items-start">        <div>          <h3 className="font-medium">{getTaskTitle(task)}</h3>          <p className="text-sm text-gray-600">{getTaskDescription(task)}</p>        </div>        {urgencyBadge[task.urgency]}      </div>      {task.due_at && (        <p className="text-xs text-gray-500 mt-2">Due: {formatDate(task.due_at)}</p>      )}      <Link href={getTaskUrl(task)} className="mt-3 inline-block text-blue-600 text-sm">        {task.urgency === 'escalated' ? 'Respond Now ?' : 'View ?'}      </Link>    </div>  );}function getTaskTitle(task: any): string {  switch (task.task_type) {    case 'respond_to_rsvp':      return `RSVP to ${task.metadata?.chapter_name || 'Chapter'} Meeting`;    case 'contact_unresponsive_member':      return `Contact ${task.metadata?.member_name || 'Member'} About RSVP`;    default:      return 'Task';  }}function getTaskUrl(task: any): string {  switch (task.task_type) {    case 'respond_to_rsvp':      return `/tasks/meeting-cycle/respond-to-rsvp?meeting=${task.related_entity_id}`;    case 'contact_unresponsive_member':      return `/tasks/meeting-cycle/contact-unresponsive-member?attendance=${task.related_entity_id}&task=${task.id}`;    default:      return '/dashboard';  }}Step 13: Create Test Seed Data for EscalationTo test the escalation flow, you need:* A meeting 3 days from now (to test reminder)* A meeting 2 days from now (to test leader task creation)* Members with no RSVP response/scripts/seed-escalation-test.sql-- Run this after Session 2 seed data-- Uses same chapter and user from Session 2-- Create a meeting 3 days from now (will trigger reminder)INSERT INTO meetings (id, chapter_id, scheduled_date, scheduled_time, location, status, rsvp_deadline)VALUES (  'c3d4e5f6-a7b8-9012-cdef-345678901234',  'a1b2c3d4-e5f6-7890-abcd-ef1234567890', -- The Oak Chapter  CURRENT_DATE + INTERVAL '3 days',  '09:00',  '123 Main St, Austin, TX',  'scheduled',  CURRENT_DATE + INTERVAL '1 day');-- Create attendance with no responseINSERT INTO attendance (meeting_id, user_id, rsvp_status)VALUES (  'c3d4e5f6-a7b8-9012-cdef-345678901234',  'YOUR_USER_ID',  'no_response');-- Create pending RSVP taskINSERT INTO pending_tasks (task_type, assigned_to, related_entity_type, related_entity_id, metadata, due_at, urgency)VALUES (  'respond_to_rsvp',  'YOUR_USER_ID',  'meeting',  'c3d4e5f6-a7b8-9012-cdef-345678901234',  '{"chapter_name": "The Oak Chapter"}'::jsonb,  CURRENT_DATE + INTERVAL '1 day',  'normal');-- Create a meeting 2 days from now (will trigger leader task)INSERT INTO meetings (id, chapter_id, scheduled_date, scheduled_time, location, status, rsvp_deadline)VALUES (  'd4e5f6a7-b8c9-0123-def0-456789012345',  'a1b2c3d4-e5f6-7890-abcd-ef1234567890',  CURRENT_DATE + INTERVAL '2 days',  '09:00',  '123 Main St, Austin, TX',  'scheduled',  CURRENT_DATE);-- Attendance with no response AND already remindedINSERT INTO attendance (meeting_id, user_id, rsvp_status, reminder_sent_at)VALUES (  'd4e5f6a7-b8c9-0123-def0-456789012345',  'YOUR_USER_ID',  'no_response',  CURRENT_DATE - INTERVAL '1 day' -- Reminder was sent yesterday);-- Pending task already at 'reminded' urgencyINSERT INTO pending_tasks (task_type, assigned_to, related_entity_type, related_entity_id, metadata, due_at, urgency)VALUES (  'respond_to_rsvp',  'YOUR_USER_ID',  'meeting',  'd4e5f6a7-b8c9-0123-def0-456789012345',  '{"chapter_name": "The Oak Chapter"}'::jsonb,  CURRENT_DATE,  'reminded');-- Make yourself a leader so you can see the contact taskUPDATE chapter_memberships SET role = 'leader' WHERE user_id = 'YOUR_USER_ID'   AND chapter_id = 'a1b2c3d4-e5f6-7890-abcd-ef1234567890';Step 14: Test the Complete Escalation FlowTest A: Reminder Flow (3 days before)1. Run seed-escalation-test.sql2. Trigger escalation manually (via admin button or API)3. Check notification_log: should have simulated email + SMS for the meeting 3 days out4. Check attendance: reminder_sent_at should be set5. Check pending_tasks: urgency should be 'reminded'6. View dashboard: RSVP task should show orange with "Texted & Emailed" badgeTest B: Leader Task Flow (2 days before)1. Trigger escalation again (for 2-day meeting)2. Check pending_tasks: should have new contact_unresponsive_member task3. Check notification_log: should have simulated email to leader4. View dashboard as leader: should see contact task5. Click contact task: should see member's phone, notes field6. Log outreach with notes7. Check: both tasks completed, agenda item created, attendance updatedTest C: RSVP List View1. Go to RSVP list for the escalated meeting2. As leader: should see phone numbers, log outreach field3. After logging: should show "Leader spoke with [name]: [notes]"Session 3 Success Criteria* [ ] notification_log table exists and records simulated sends* [ ] meeting_agenda_items table exists* [ ] Admin notification log viewer shows simulated emails/texts* [ ] Escalation logic correctly identifies meetings at 3 and 2 days out* [ ] Reminder notifications are logged for non-responders at 3 days* [ ] Pending task urgency updates to 'reminded' after reminder* [ ] Leader task created at 2 days for still-unresponsive members* [ ] RSVP task urgency updates to 'escalated' at 2 days* [ ] Visual urgency (orange styling) shows on escalated tasks* [ ] RSVP list shows escalation status to all members* [ ] Leader sees phone numbers and log field on RSVP list* [ ] Contact task screen shows member info and notes field* [ ] Logging outreach completes both Leader and Member tasks* [ ] Logging outreach creates meeting agenda item* [ ] Attendance record updated with outreach notesWhat We're NOT Building in Session 3* Actual email/SMS sending (simulated only, code commented for future)* Leader miss flagging to PUNC admin (future session)* Automatic meeting generation from recurring schedule (future session)* Full meeting runner (Session 6)Notes for Future SessionsSession 4: Check-in to Meeting* Member check-in task when meeting starts* Attendance recording (in_person / video)Email/SMS Implementation (when ready):* Sign up for Resend (email) and Twilio (SMS)* Add API keys to environment variables* Update sendNotification() to make real API calls* Change status from 'simulated' to 'sent' or 'failed'* The notification_log structure is already ready for thisRemember: The task is the unit of work. Escalation creates new tasks, not just notifications.