PUNCapp Session 6: Full Check-ins & CommitmentsContextSession 5 built the Opening and Lightning Round. Now we build Full Check-ins Ñ the heart of the PUNC meeting where men share deeply, manage their Stretch Goals, and request support.Meeting structure reminder:1. ? Opening Ñ Meditation, Ethos reading (Session 5)2. ? Lightning Round Ñ Each man ~1 min, priority assigned (Session 5)3. Full Check-ins Ñ Longer sharing, Stretch Goals, Support requests (Session 6)4. Closing Ñ Ratings, audio recording, Commitments formalized (Session 7)Session 6 scope: Full Check-ins + Commitments tablePrimary References1. TOD-SPECIFICATION.md Ñ Flow 1: Meeting Cycle2. CLAUDE-CODE-GUIDE.md Ñ Implementation patterns3. SESSION-5-PROMPT.md Ñ Timer widget, meeting runner structureStep 1: Create the Commitments TableCREATE TABLE commitments (  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),    -- Who made the commitment  committer_id uuid NOT NULL REFERENCES public.users(id),    -- Type of commitment  commitment_type text NOT NULL CHECK (commitment_type IN (    'stretch_goal',    'support_a_man',    'chapter',    'community',    'self'  )),    -- The commitment itself  description text NOT NULL,    -- Optional receiver (for support_a_man type, or self-commitments)  receiver_id uuid REFERENCES public.users(id),    -- Optional chapter reference (for chapter commitments)  chapter_id uuid REFERENCES chapters(id),    -- Optional due date (triggers pending_task if set)  due_date date,    -- Status tracking  status text NOT NULL DEFAULT 'active' CHECK (status IN (    'active',    'completed',    'replaced',  -- when a new stretch goal replaces the old one    'expired'    -- past due date without completion  )),    -- Meeting context  created_at_meeting_id uuid REFERENCES meetings(id),  -- where it was created  completed_at_meeting_id uuid REFERENCES meetings(id), -- where it was completed (if applicable)    -- Timestamps  created_at timestamptz DEFAULT now(),  updated_at timestamptz DEFAULT now(),  completed_at timestamptz);ALTER TABLE commitments ENABLE ROW LEVEL SECURITY;-- Users can see commitments they made or receivedCREATE POLICY "Users can view own commitments" ON commitments  FOR SELECT USING (    committer_id = auth.uid() OR     receiver_id = auth.uid() OR    chapter_id IN (      SELECT chapter_id FROM chapter_memberships       WHERE user_id = auth.uid() AND is_active = true    )  );-- Users can create commitmentsCREATE POLICY "Users can create commitments" ON commitments  FOR INSERT WITH CHECK (auth.role() = 'authenticated');-- Users can update their own commitmentsCREATE POLICY "Users can update own commitments" ON commitments  FOR UPDATE USING (committer_id = auth.uid());-- Indexes for common queriesCREATE INDEX idx_commitments_committer ON commitments(committer_id, status);CREATE INDEX idx_commitments_receiver ON commitments(receiver_id, status) WHERE receiver_id IS NOT NULL;CREATE INDEX idx_commitments_stretch_goal ON commitments(committer_id, commitment_type, status)   WHERE commitment_type = 'stretch_goal' AND status = 'active';CREATE INDEX idx_commitments_due_date ON commitments(due_date, status)   WHERE due_date IS NOT NULL AND status = 'active';-- Trigger to update updated_atCREATE OR REPLACE FUNCTION update_commitment_timestamp()RETURNS TRIGGER AS $$BEGIN  NEW.updated_at = now();  RETURN NEW;END;$$ LANGUAGE plpgsql;CREATE TRIGGER commitments_updated_at  BEFORE UPDATE ON commitments  FOR EACH ROW  EXECUTE FUNCTION update_commitment_timestamp();Step 2: Add Full Check-in Fields to Meeting Time Log-- Add fields for Full Check-in trackingALTER TABLE meeting_time_log  ADD COLUMN IF NOT EXISTS stretch_goal_action text CHECK (stretch_goal_action IN (    'kept',       -- renewed same goal    'completed',  -- marked as done    'new',        -- created new goal    'none'        -- had no goal, didn't create one  )),  ADD COLUMN IF NOT EXISTS requested_support boolean DEFAULT false,  ADD COLUMN IF NOT EXISTS new_stretch_goal_id uuid REFERENCES commitments(id);Step 3: Create Pending Task for Stretch Goal EntryWhen a man defers entering his new Stretch Goal, create a pending_task.-- No schema change needed, we'll use existing pending_tasks table with:-- task_type = 'enter_stretch_goal'-- related_entity_type = 'meeting'-- related_entity_id = meeting_idStep 4: Create Pending Tasks for Commitments with Due DatesFunction to create pending_task when commitment has a due date:CREATE OR REPLACE FUNCTION create_commitment_task()RETURNS TRIGGER AS $$BEGIN  -- Only create task if there's a due date  IF NEW.due_date IS NOT NULL AND NEW.status = 'active' THEN    INSERT INTO pending_tasks (      task_type,      assigned_to,      related_entity_type,      related_entity_id,      due_date,      metadata    ) VALUES (      'fulfill_commitment',      NEW.committer_id,      'commitment',      NEW.id,      NEW.due_date,      jsonb_build_object(        'commitment_type', NEW.commitment_type,        'description', NEW.description,        'receiver_id', NEW.receiver_id      )    );  END IF;  RETURN NEW;END;$$ LANGUAGE plpgsql;CREATE TRIGGER commitment_task_trigger  AFTER INSERT ON commitments  FOR EACH ROW  EXECUTE FUNCTION create_commitment_task();Step 5: Build the Full Check-in Transition ScreenWhen Lightning Round ends, show a summary before starting Full Check-ins./components/meeting/FullCheckinSetup.tsx'use client';import { useState, useEffect } from 'react';interface Attendee {  user_id: string;  user: {    id: string;    name: string;    username: string | null;  };}interface LightningLog {  user_id: string;  priority: number | null;  skipped: boolean;}interface FullCheckinSetupProps {  attendees: Attendee[];  lightningLogs: LightningLog[];  meetingEndTime: Date;  isScribe: boolean;  onStart: (queue: CheckinQueueItem[]) => void;}interface CheckinQueueItem {  user_id: string;  user: { id: string; name: string; username: string | null };  priority: number;  skipped: boolean;}export function FullCheckinSetup({  attendees,  lightningLogs,  meetingEndTime,  isScribe,  onStart,}: FullCheckinSetupProps) {  // Build initial queue from lightning round results  const [queue, setQueue] = useState<CheckinQueueItem[]>([]);    useEffect(() => {    // Match attendees with their lightning round data    const queueItems: CheckinQueueItem[] = attendees.map(a => {      const log = lightningLogs.find(l => l.user_id === a.user_id);      return {        user_id: a.user_id,        user: a.user,        priority: log?.priority ?? 2, // Default P2 if no lightning data        skipped: false, // Start fresh for full checkins      };    });        // Sort: P1s first, then P2s (maintain order within each group)    queueItems.sort((a, b) => a.priority - b.priority);        setQueue(queueItems);  }, [attendees, lightningLogs]);    // Calculate time allocation  const now = new Date();  const timeUntilEnd = Math.max(0, meetingEndTime.getTime() - now.getTime());  const availableMinutes = Math.floor(timeUntilEnd / 60000) - 30; // Reserve 30 min for closing  const activeMembers = queue.filter(q => !q.skipped).length;  const minutesPerPerson = activeMembers > 0 ? Math.floor(availableMinutes / activeMembers) : 0;  const secondsPerPerson = minutesPerPerson * 60;    function toggleSkip(userId: string) {    setQueue(prev => prev.map(q =>       q.user_id === userId ? { ...q, skipped: !q.skipped } : q    ));  }    function getDisplayName(item: CheckinQueueItem): string {    return item.user.username || item.user.name;  }    // Separate P1s and P2s for display  const p1Members = queue.filter(q => q.priority === 1);  const p2Members = queue.filter(q => q.priority === 2);    return (    <div className="space-y-6">      <div className="text-center">        <h2 className="text-2xl font-bold mb-2">Full Check-ins</h2>        <p className="text-gray-600">Review the queue before starting</p>      </div>            {/* Time allocation display */}      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">        <p className="text-sm text-blue-600 mb-1">Time per person</p>        <p className="text-3xl font-bold text-blue-800">          {minutesPerPerson} min        </p>        <p className="text-sm text-blue-600 mt-1">          {availableMinutes} min available Ö {activeMembers} members        </p>        {availableMinutes <= 0 && (          <p className="text-red-600 mt-2 font-medium">            ?? No time remaining! Add time or skip members.          </p>        )}      </div>            {/* P1 Queue */}      <div className="bg-orange-50 rounded-lg p-4">        <h3 className="font-medium text-orange-800 mb-3">          Priority 1 ({p1Members.filter(m => !m.skipped).length} members)        </h3>        <div className="space-y-2">          {p1Members.map((item, index) => (            <div              key={item.user_id}              className={`flex items-center justify-between p-2 rounded ${                item.skipped ? 'bg-gray-100 opacity-50' : 'bg-white'              }`}            >              <div className="flex items-center gap-3">                <span className="text-gray-400 w-6">{index + 1}.</span>                <span className={item.skipped ? 'line-through text-gray-400' : 'font-medium'}>                  {getDisplayName(item)}                </span>              </div>              {/* P1s cannot be pre-skipped */}            </div>          ))}          {p1Members.length === 0 && (            <p className="text-gray-500 text-sm">No P1 members</p>          )}        </div>      </div>            {/* P2 Queue */}      <div className="bg-blue-50 rounded-lg p-4">        <h3 className="font-medium text-blue-800 mb-3">          Priority 2 ({p2Members.filter(m => !m.skipped).length} members)        </h3>        <div className="space-y-2">          {p2Members.map((item, index) => (            <div              key={item.user_id}              className={`flex items-center justify-between p-2 rounded ${                item.skipped ? 'bg-gray-100 opacity-50' : 'bg-white'              }`}            >              <div className="flex items-center gap-3">                <span className="text-gray-400 w-6">{p1Members.length + index + 1}.</span>                <span className={item.skipped ? 'line-through text-gray-400' : 'font-medium'}>                  {getDisplayName(item)}                </span>              </div>              {isScribe && (                <button                  onClick={() => toggleSkip(item.user_id)}                  className={`text-sm px-3 py-1 rounded ${                    item.skipped                      ? 'bg-green-100 text-green-700 hover:bg-green-200'                      : 'bg-gray-200 text-gray-600 hover:bg-gray-300'                  }`}                >                  {item.skipped ? 'Restore' : 'Skip'}                </button>              )}            </div>          ))}          {p2Members.length === 0 && (            <p className="text-gray-500 text-sm">No P2 members</p>          )}        </div>      </div>            {/* Start button */}      {isScribe && (        <button          onClick={() => onStart(queue)}          disabled={activeMembers === 0 || minutesPerPerson <= 0}          className={`w-full py-3 rounded-lg font-medium ${            activeMembers > 0 && minutesPerPerson > 0              ? 'bg-blue-600 text-white hover:bg-blue-700'              : 'bg-gray-300 text-gray-500 cursor-not-allowed'          }`}        >          Start Full Check-ins ?        </button>      )}    </div>  );}Step 6: Build the Full Check-in Component/components/meeting/FullCheckin.tsx'use client';import { useState, useEffect, useMemo } from 'react';import { TimerWidget } from './TimerWidget';interface CheckinQueueItem {  user_id: string;  user: { id: string; name: string; username: string | null };  priority: number;  skipped: boolean;}interface StretchGoal {  id: string;  description: string;}interface CheckinLog {  user_id: string;  duration_seconds: number;  overtime_seconds: number;  skipped: boolean;  stretch_goal_action: string | null;  requested_support: boolean;}interface FullCheckinProps {  queue: CheckinQueueItem[];  isScribe: boolean;  meetingEndTime: Date;  completedLogs: CheckinLog[];  stretchGoals: Record<string, StretchGoal | null>; // user_id -> their active stretch goal  onPersonComplete: (    userId: string,    durationSeconds: number,    overtimeSeconds: number,    stretchGoalAction: 'kept' | 'completed' | 'new' | 'none',    requestedSupport: boolean,    newStretchGoalText?: string  ) => void;  onPersonSkip: (userId: string) => void;  onAddMeetingTime: (minutes: number) => void;  onDitchCurriculum: () => void;  onRoundComplete: () => void;  curriculumDitched: boolean;}export function FullCheckin({  queue,  isScribe,  meetingEndTime,  completedLogs,  stretchGoals,  onPersonComplete,  onPersonSkip,  onAddMeetingTime,  onDitchCurriculum,  onRoundComplete,  curriculumDitched,}: FullCheckinProps) {  const [currentIndex, setCurrentIndex] = useState(0);  const [startTime, setStartTime] = useState<Date | null>(null);  const [localQueue, setLocalQueue] = useState(queue);    // Stretch goal UI state for current person  const [stretchAction, setStretchAction] = useState<'kept' | 'completed' | 'new' | 'none' | null>(null);  const [newStretchGoalText, setNewStretchGoalText] = useState('');  const [requestedSupport, setRequestedSupport] = useState(false);  const [deferStretchGoal, setDeferStretchGoal] = useState(false);    // Get completed/skipped user IDs  const completedUserIds = new Set(completedLogs.map(l => l.user_id));    // Find current person (skip already completed/skipped)  const activeQueue = localQueue.filter(q => !q.skipped);  const currentPerson = activeQueue.find(q => !completedUserIds.has(q.user_id));  const currentStretchGoal = currentPerson ? stretchGoals[currentPerson.user_id] : null;    // Calculate time per person dynamically  const timeAllocation = useMemo(() => {    const now = new Date();    const timeUntilEnd = Math.max(0, meetingEndTime.getTime() - now.getTime());    const reservedMinutes = curriculumDitched ? 0 : 30; // 30 min for closing, 0 if curriculum ditched    const availableMinutes = Math.floor(timeUntilEnd / 60000) - reservedMinutes;        const remainingMembers = activeQueue.filter(q => !completedUserIds.has(q.user_id)).length;    const minutesPerPerson = remainingMembers > 0 ? Math.max(1, Math.floor(availableMinutes / remainingMembers)) : 0;        return {      availableMinutes,      remainingMembers,      minutesPerPerson,      secondsPerPerson: minutesPerPerson * 60,    };  }, [meetingEndTime, activeQueue, completedUserIds, curriculumDitched]);    // Check if we're out of time  const outOfTime = timeAllocation.availableMinutes <= 0;    // Reset UI state when moving to next person  useEffect(() => {    setStretchAction(null);    setNewStretchGoalText('');    setRequestedSupport(false);    setDeferStretchGoal(false);    setStartTime(null);  }, [currentPerson?.user_id]);    function handleStart() {    setStartTime(new Date());  }    function handleSkipP2(userId: string) {    // Can only skip P2s    const person = localQueue.find(q => q.user_id === userId);    if (person?.priority !== 2) return;        setLocalQueue(prev => prev.map(q =>      q.user_id === userId ? { ...q, skipped: true } : q    ));    onPersonSkip(userId);  }    function handleNext(overtimeSeconds: number) {    if (!currentPerson || !startTime) return;        const endTime = new Date();    const durationSeconds = Math.round((endTime.getTime() - startTime.getTime()) / 1000);        // Determine stretch goal action    let finalStretchAction: 'kept' | 'completed' | 'new' | 'none' = 'none';    let finalNewStretchGoalText: string | undefined;        if (currentStretchGoal) {      // Had a stretch goal      finalStretchAction = stretchAction || 'kept'; // Default to kept if not specified    } else {      // No stretch goal      if (stretchAction === 'new') {        finalStretchAction = 'new';      } else {        finalStretchAction = 'none';      }    }        // Handle new stretch goal text    if (finalStretchAction === 'new') {      if (deferStretchGoal || !newStretchGoalText.trim()) {        // Will create pending_task for later entry        finalNewStretchGoalText = undefined;      } else {        finalNewStretchGoalText = newStretchGoalText.trim();      }    }        onPersonComplete(      currentPerson.user_id,      durationSeconds,      overtimeSeconds,      finalStretchAction,      requestedSupport,      finalNewStretchGoalText    );        setCurrentIndex(prev => prev + 1);  }    function handleAddTime(seconds: number) {    // This is for the timer widget's internal +30 sec    console.log(`Added ${seconds} seconds to current person`);  }    function getDisplayName(item: CheckinQueueItem): string {    return item.user.username || item.user.name;  }    // Check if round is complete  const isComplete = !currentPerson && completedLogs.length > 0;    if (isComplete) {    const completedCount = completedLogs.filter(l => !l.skipped).length;    const supportRequests = completedLogs.filter(l => l.requested_support).length;        return (      <div className="text-center py-8">        <h3 className="text-xl font-bold text-green-600 mb-4">Full Check-ins Complete!</h3>        <p className="text-gray-600 mb-2">          {completedCount} members checked in.        </p>        {supportRequests > 0 && (          <p className="text-orange-600 mb-4">            {supportRequests} member{supportRequests > 1 ? 's' : ''} requested support.          </p>        )}        {isScribe && (          <button            onClick={onRoundComplete}            className="px-6 py-3 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700"          >            {curriculumDitched ? 'Proceed to Closing ?' : 'Proceed to Curriculum ?'}          </button>        )}      </div>    );  }    // Out of time screen  if (outOfTime && !currentPerson) {    return (      <div className="space-y-6">        <div className="bg-red-50 border border-red-200 rounded-lg p-6 text-center">          <h3 className="text-xl font-bold text-red-600 mb-2">?? Out of Time</h3>          <p className="text-gray-600 mb-4">            No time remaining for check-ins. Choose an option:          </p>                    {isScribe && (            <div className="space-y-3">              <button                onClick={() => onAddMeetingTime(5)}                className="w-full py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700"              >                Add 5 Minutes to Meeting              </button>                            {!curriculumDitched && (                <button                  onClick={onDitchCurriculum}                  className="w-full py-2 bg-orange-600 text-white rounded-lg font-medium hover:bg-orange-700"                >                  Ditch Curriculum (+30 min for Check-ins)                </button>              )}                            <p className="text-sm text-gray-500 mt-4">                Or skip P2 members below to free up time.              </p>            </div>          )}        </div>                {/* Show remaining queue for skipping */}        <RemainingQueue          queue={localQueue}          completedUserIds={completedUserIds}          isScribe={isScribe}          onSkip={handleSkipP2}        />      </div>    );  }    return (    <div className="space-y-6">      {/* Time allocation header */}      <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 flex justify-between items-center">        <div>          <span className="text-sm text-blue-600">Time per person: </span>          <span className="font-bold text-blue-800">{timeAllocation.minutesPerPerson} min</span>        </div>        <div className="text-sm text-blue-600">          {timeAllocation.remainingMembers} remaining        </div>      </div>            {/* Scribe time controls */}      {isScribe && (        <div className="flex gap-2 justify-center">          <button            onClick={() => onAddMeetingTime(5)}            className="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300"          >            Add 5 to Meeting          </button>          {!curriculumDitched && (            <button              onClick={onDitchCurriculum}              className="px-3 py-1 text-sm bg-orange-100 text-orange-700 rounded hover:bg-orange-200"            >              Ditch Curriculum            </button>          )}        </div>      )}            {/* Timer Widget */}      {currentPerson && (        <TimerWidget          currentPerson={{            id: currentPerson.user_id,            name: getDisplayName(currentPerson),          }}          allottedSeconds={timeAllocation.secondsPerPerson}          isScribe={isScribe}          section="full_checkins"          onNext={handleNext}          onSkip={() => {}} // Can't skip during checkin, only before          onAddTime={handleAddTime}        />      )}            {/* Stretch Goal section (Scribe only during check-in) */}      {isScribe && currentPerson && startTime && (        <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">          <h4 className="font-medium text-amber-800 mb-3">Stretch Goal</h4>                    {currentStretchGoal ? (            <div className="mb-3 p-2 bg-white rounded border">              <p className="text-sm text-gray-500">Current goal:</p>              <p className="font-medium">{currentStretchGoal.description}</p>            </div>          ) : (            <p className="text-sm text-gray-500 mb-3">No current stretch goal</p>          )}                    <div className="flex flex-wrap gap-2 mb-3">            {currentStretchGoal && (              <>                <button                  onClick={() => setStretchAction('kept')}                  className={`px-3 py-1 rounded text-sm font-medium ${                    stretchAction === 'kept'                      ? 'bg-amber-600 text-white'                      : 'bg-white border border-amber-300 text-amber-700 hover:bg-amber-100'                  }`}                >                  Keep                </button>                <button                  onClick={() => setStretchAction('completed')}                  className={`px-3 py-1 rounded text-sm font-medium ${                    stretchAction === 'completed'                      ? 'bg-green-600 text-white'                      : 'bg-white border border-green-300 text-green-700 hover:bg-green-100'                  }`}                >                  Complete                </button>              </>            )}            <button              onClick={() => setStretchAction('new')}              className={`px-3 py-1 rounded text-sm font-medium ${                stretchAction === 'new'                  ? 'bg-blue-600 text-white'                  : 'bg-white border border-blue-300 text-blue-700 hover:bg-blue-100'              }`}            >              New Goal            </button>          </div>                    {/* New stretch goal input */}          {stretchAction === 'new' && (            <div className="space-y-2">              <textarea                value={newStretchGoalText}                onChange={(e) => setNewStretchGoalText(e.target.value)}                placeholder="Enter new stretch goal..."                className="w-full p-2 border rounded text-sm"                rows={2}                disabled={deferStretchGoal}              />              <label className="flex items-center gap-2 text-sm text-gray-600">                <input                  type="checkbox"                  checked={deferStretchGoal}                  onChange={(e) => setDeferStretchGoal(e.target.checked)}                />                He'll enter it later (creates task)              </label>            </div>          )}        </div>      )}            {/* Support request toggle (Scribe only during check-in) */}      {isScribe && currentPerson && startTime && (        <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">          <label className="flex items-center gap-3">            <input              type="checkbox"              checked={requestedSupport}              onChange={(e) => setRequestedSupport(e.target.checked)}              className="w-5 h-5 text-purple-600"            />            <span className="font-medium text-purple-800">Requested Support</span>          </label>          {requestedSupport && (            <p className="text-sm text-purple-600 mt-2">              Support commitments will be formalized in Closing.            </p>          )}        </div>      )}            {/* Queue display */}      <RemainingQueue        queue={localQueue}        completedUserIds={completedUserIds}        completedLogs={completedLogs}        currentUserId={currentPerson?.user_id}        isScribe={isScribe}        onSkip={handleSkipP2}      />    </div>  );}// Extracted queue display componentfunction RemainingQueue({  queue,  completedUserIds,  completedLogs = [],  currentUserId,  isScribe,  onSkip,}: {  queue: CheckinQueueItem[];  completedUserIds: Set<string>;  completedLogs?: CheckinLog[];  currentUserId?: string;  isScribe: boolean;  onSkip: (userId: string) => void;}) {  function getDisplayName(item: CheckinQueueItem): string {    return item.user.username || item.user.name;  }    function formatDuration(seconds: number): string {    const mins = Math.floor(seconds / 60);    const secs = seconds % 60;    return `${mins}:${secs.toString().padStart(2, '0')}`;  }    return (    <div className="bg-gray-50 rounded-lg p-4">      <h4 className="text-sm font-medium text-gray-700 mb-3">Queue</h4>      <div className="space-y-2">        {queue.map((item) => {          const log = completedLogs.find(l => l.user_id === item.user_id);          const isCompleted = completedUserIds.has(item.user_id);          const isCurrent = item.user_id === currentUserId;          const isSkipped = item.skipped || log?.skipped;          const isPending = !isCompleted && !isCurrent && !isSkipped;                    return (            <div              key={item.user_id}              className={`flex items-center justify-between p-2 rounded ${                isCurrent ? 'bg-blue-100 border-2 border-blue-400' :                isCompleted ? 'bg-green-50' :                isSkipped ? 'bg-gray-100 opacity-50' :                'bg-white'              }`}            >              <div className="flex items-center gap-3">                <span className="text-gray-400">                  {isCompleted ? '?' : isCurrent ? '?' : isSkipped ? 'Ð' : '?'}                </span>                <span className={`font-medium ${isSkipped ? 'line-through text-gray-400' : ''}`}>                  {getDisplayName(item)}                </span>                <span className={`text-xs px-1.5 py-0.5 rounded ${                  item.priority === 1 ? 'bg-orange-200 text-orange-800' : 'bg-blue-200 text-blue-800'                }`}>                  P{item.priority}                </span>              </div>                            <div className="flex items-center gap-2">                {log && !isSkipped && (                  <span className="text-sm text-gray-600">                    {formatDuration(log.duration_seconds)}                    {log.overtime_seconds > 0 && (                      <span className="text-red-500"> (+{formatDuration(log.overtime_seconds)})</span>                    )}                  </span>                )}                {log?.requested_support && (                  <span className="text-xs bg-purple-200 text-purple-800 px-1.5 py-0.5 rounded">                    Support                  </span>                )}                {isSkipped && (                  <span className="text-xs text-gray-400">Skipped</span>                )}                {/* Can skip P2s that haven't gone yet */}                {isScribe && isPending && item.priority === 2 && (                  <button                    onClick={() => onSkip(item.user_id)}                    className="text-xs px-2 py-1 bg-gray-200 text-gray-600 rounded hover:bg-gray-300"                  >                    Skip                  </button>                )}              </div>            </div>          );        })}      </div>    </div>  );}Step 7: Create Full Check-in Server Actions/app/meetings/[meetingId]/run/actions.ts (add to existing file)export async function logFullCheckin(  meetingId: string,  userId: string,  durationSeconds: number,  overtimeSeconds: number,  stretchGoalAction: 'kept' | 'completed' | 'new' | 'none',  requestedSupport: boolean,  newStretchGoalText?: string) {  const supabase = await createClient();    const { data: { user } } = await supabase.auth.getUser();  if (!user) throw new Error('Not authenticated');    const now = new Date();  const startTime = new Date(now.getTime() - durationSeconds * 1000);    // Get user's current stretch goal (if any)  const { data: currentStretchGoal } = await supabase    .from('commitments')    .select('id')    .eq('committer_id', userId)    .eq('commitment_type', 'stretch_goal')    .eq('status', 'active')    .single();    let newStretchGoalId: string | null = null;    // Handle stretch goal actions  if (stretchGoalAction === 'completed' && currentStretchGoal) {    // Mark current goal as completed    await supabase      .from('commitments')      .update({        status: 'completed',        completed_at: now.toISOString(),        completed_at_meeting_id: meetingId,      })      .eq('id', currentStretchGoal.id);  }    if (stretchGoalAction === 'new') {    if (newStretchGoalText) {      // Replace old goal and create new one      if (currentStretchGoal) {        await supabase          .from('commitments')          .update({ status: 'replaced' })          .eq('id', currentStretchGoal.id);      }            const { data: newGoal } = await supabase        .from('commitments')        .insert({          committer_id: userId,          commitment_type: 'stretch_goal',          description: newStretchGoalText,          created_at_meeting_id: meetingId,        })        .select('id')        .single();            newStretchGoalId = newGoal?.id || null;    } else {      // Create pending task for user to enter goal later      await supabase.from('pending_tasks').insert({        task_type: 'enter_stretch_goal',        assigned_to: userId,        related_entity_type: 'meeting',        related_entity_id: meetingId,        metadata: {          reason: 'Deferred stretch goal entry from meeting',        },      });    }  }    // Log the check-in  await supabase.from('meeting_time_log').insert({    meeting_id: meetingId,    section: 'full_checkins',    user_id: userId,    start_time: startTime.toISOString(),    end_time: now.toISOString(),    duration_seconds: durationSeconds,    overtime_seconds: overtimeSeconds,    stretch_goal_action: stretchGoalAction,    requested_support: requestedSupport,    new_stretch_goal_id: newStretchGoalId,    skipped: false,  });    revalidatePath(`/meetings/${meetingId}/run`);}export async function skipFullCheckin(meetingId: string, userId: string) {  const supabase = await createClient();    const { data: { user } } = await supabase.auth.getUser();  if (!user) throw new Error('Not authenticated');    const now = new Date().toISOString();    await supabase.from('meeting_time_log').insert({    meeting_id: meetingId,    section: 'full_checkins',    user_id: userId,    start_time: now,    end_time: now,    duration_seconds: 0,    overtime_seconds: 0,    skipped: true,  });    revalidatePath(`/meetings/${meetingId}/run`);}export async function addMeetingTime(meetingId: string, minutes: number) {  const supabase = await createClient();    const { data: { user } } = await supabase.auth.getUser();  if (!user) throw new Error('Not authenticated');    // Get current meeting duration  const { data: meeting } = await supabase    .from('meetings')    .select('duration_minutes')    .eq('id', meetingId)    .single();    if (!meeting) throw new Error('Meeting not found');    // Add time  await supabase    .from('meetings')    .update({ duration_minutes: meeting.duration_minutes + minutes })    .eq('id', meetingId);    revalidatePath(`/meetings/${meetingId}/run`);}export async function ditchCurriculum(meetingId: string) {  const supabase = await createClient();    const { data: { user } } = await supabase.auth.getUser();  if (!user) throw new Error('Not authenticated');    // Mark curriculum as ditched (we'll add this field)  await supabase    .from('meetings')    .update({ curriculum_ditched: true })    .eq('id', meetingId);    revalidatePath(`/meetings/${meetingId}/run`);}Step 8: Add Curriculum Ditched FieldALTER TABLE meetings  ADD COLUMN IF NOT EXISTS curriculum_ditched boolean DEFAULT false;Step 9: Update Meeting Runner Page for Full Check-insUpdate /app/meetings/[meetingId]/run/page.tsx to include Full Check-in section:// Add to importsimport { FullCheckinSetup } from '@/components/meeting/FullCheckinSetup';import { FullCheckin } from '@/components/meeting/FullCheckin';// Add to context loading - fetch stretch goals for all attendeesconst attendeeUserIds = attendees.map(a => a.user_id);const { data: stretchGoals } = await supabase  .from('commitments')  .select('id, committer_id, description')  .eq('commitment_type', 'stretch_goal')  .eq('status', 'active')  .in('committer_id', attendeeUserIds);// Transform to lookup objectconst stretchGoalsByUser: Record<string, { id: string; description: string } | null> = {};attendeeUserIds.forEach(userId => {  const goal = stretchGoals?.find(g => g.committer_id === userId);  stretchGoalsByUser[userId] = goal ? { id: goal.id, description: goal.description } : null;});// In the JSX, replace the placeholder:{meeting.current_section === 'full_checkins' && (  <FullCheckinSection    attendees={attendees}    lightningLogs={lightningLogs}    meetingEndTime={meetingEndTime}    isScribe={isScribe}    meeting={meeting}    stretchGoalsByUser={stretchGoalsByUser}  />)}// New client wrapper component for full check-in flow// This manages the setup -> checkin transitionStep 10: Create Full Check-in Section Wrapper/components/meeting/FullCheckinSection.tsx'use client';import { useState } from 'react';import { FullCheckinSetup } from './FullCheckinSetup';import { FullCheckin } from './FullCheckin';import {   logFullCheckin,   skipFullCheckin,   addMeetingTime,   ditchCurriculum,  advanceSection } from '@/app/meetings/[meetingId]/run/actions';interface FullCheckinSectionProps {  meetingId: string;  attendees: any[];  lightningLogs: any[];  fullCheckinLogs: any[];  meetingEndTime: Date;  isScribe: boolean;  curriculumDitched: boolean;  stretchGoalsByUser: Record<string, { id: string; description: string } | null>;}export function FullCheckinSection({  meetingId,  attendees,  lightningLogs,  fullCheckinLogs,  meetingEndTime,  isScribe,  curriculumDitched,  stretchGoalsByUser,}: FullCheckinSectionProps) {  const [isSetupComplete, setIsSetupComplete] = useState(fullCheckinLogs.length > 0);  const [queue, setQueue] = useState<any[]>([]);    function handleSetupComplete(initialQueue: any[]) {    setQueue(initialQueue);    setIsSetupComplete(true);  }    async function handlePersonComplete(    userId: string,    durationSeconds: number,    overtimeSeconds: number,    stretchGoalAction: 'kept' | 'completed' | 'new' | 'none',    requestedSupport: boolean,    newStretchGoalText?: string  ) {    await logFullCheckin(      meetingId,      userId,      durationSeconds,      overtimeSeconds,      stretchGoalAction,      requestedSupport,      newStretchGoalText    );  }    async function handlePersonSkip(userId: string) {    await skipFullCheckin(meetingId, userId);  }    async function handleAddMeetingTime(minutes: number) {    await addMeetingTime(meetingId, minutes);  }    async function handleDitchCurriculum() {    await ditchCurriculum(meetingId);  }    async function handleRoundComplete() {    const nextSection = curriculumDitched ? 'closing' : 'curriculum';    await advanceSection(meetingId, nextSection);  }    if (!isSetupComplete) {    return (      <FullCheckinSetup        attendees={attendees}        lightningLogs={lightningLogs}        meetingEndTime={meetingEndTime}        isScribe={isScribe}        onStart={handleSetupComplete}      />    );  }    return (    <FullCheckin      queue={queue}      isScribe={isScribe}      meetingEndTime={meetingEndTime}      completedLogs={fullCheckinLogs}      stretchGoals={stretchGoalsByUser}      onPersonComplete={handlePersonComplete}      onPersonSkip={handlePersonSkip}      onAddMeetingTime={handleAddMeetingTime}      onDitchCurriculum={handleDitchCurriculum}      onRoundComplete={handleRoundComplete}      curriculumDitched={curriculumDitched}    />  );}Step 11: Add Curriculum to Meeting Sections-- Update current_section check constraint to include curriculumALTER TABLE meetings   DROP CONSTRAINT IF EXISTS meetings_current_section_check;  ALTER TABLE meetings  ADD CONSTRAINT meetings_current_section_check   CHECK (current_section IN (    'not_started',    'opening_meditation',    'opening_ethos',     'lightning_round',    'full_checkins',    'curriculum',    'closing',    'ended'  ));-- Also update meeting_time_logALTER TABLE meeting_time_log  DROP CONSTRAINT IF EXISTS meeting_time_log_section_check;ALTER TABLE meeting_time_log  ADD CONSTRAINT meeting_time_log_section_check  CHECK (section IN (    'opening_meditation',    'opening_ethos',    'lightning_round',    'full_checkins',    'curriculum',    'closing'  ));Step 12: Update Dashboard to Show Stretch Goal/app/dashboard/page.tsx (add stretch goal display)// Fetch user's active stretch goalconst { data: stretchGoal } = await supabase  .from('commitments')  .select('id, description, created_at')  .eq('committer_id', user.id)  .eq('commitment_type', 'stretch_goal')  .eq('status', 'active')  .single();// In the JSX, add above the tasks list:{stretchGoal && (  <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">    <h3 className="text-sm font-medium text-amber-800 mb-1">Current Stretch Goal</h3>    <p className="text-amber-900 font-medium">{stretchGoal.description}</p>  </div>)}Step 13: Test the Complete FlowTest A: Full Check-in Setup1. Complete Lightning Round from Session 52. Section advances to Full Check-ins3. See P1 and P2 queues with time calculation4. As Scribe, skip a P2 ? time recalculates5. Click "Start Full Check-ins"Test B: Full Check-in Flow1. See timer with calculated time per person2. Start timer, let it count down3. Tinkle sound at 1 minute remaining4. Test Stretch Goal options: Keep, Complete, New5. Test "New" with text entry6. Test "New" with defer checkbox7. Toggle "Requested Support"8. Click Next ? moves to next personTest C: Time Pressure1. Let check-ins run long2. Time per person recalculates down3. When out of time, see options: o Add 5 to Meetingo Ditch Curriculumo Skip P2sTest D: Commitments Table1. Create a new stretch goal2. Verify it appears in commitments table3. Complete a stretch goal ? status changes4. Defer a stretch goal ? pending_task createdTest E: Dashboard Stretch Goal1. Go to dashboard2. See "Current Stretch Goal" section3. Create new goal in meeting ? appears on dashboardSession 6 Success Criteria* [ ] Commitments table created with all types* [ ] Full Check-in setup shows P1/P2 queues with time calculation* [ ] Time recalculates dynamically as check-ins complete* [ ] Scribe can pre-skip P2s, time returned to pool* [ ] Timer works with tinkle at 1 minute* [ ] Stretch Goal: Keep, Complete, New options work* [ ] New stretch goal can be entered or deferred* [ ] Deferred creates pending_task* [ ] Requested Support flag captured* [ ] Add 5 to Meeting increases duration* [ ] Ditch Curriculum adds 30 min to check-in time* [ ] Full Check-in logs stored with all metadata* [ ] Dashboard shows current Stretch Goal* [ ] Section advances to Curriculum or ClosingWhat We're NOT Building in Session 6* Curriculum section (timer, content, reflection) Ñ Session 7* Closing section (ratings, "most value", audio) Ñ Session 7* Support Commitment creation Ñ Session 7* Meeting end and wrap-up Ñ Session 7Notes for Session 7: Curriculum & ClosingSession 7 will build:* Curriculum section (if not ditched): 30 min timer, Leader content, reflection question* Closing section: o Each man rates 1-10, selects "who caused most value"o Support Commitments formalized (who ? who, description)o Audio recording: "What I got out of this meeting..."o Any other Commitments (Chapter, Community, Self)* Meeting end: status ? completed, summary viewRemember: The Scribe runs the app so the men don't have to look at their phones.